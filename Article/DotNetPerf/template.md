需要纠正的一些观点
1. 托管代码比本机代码慢？
   比较接近真相的说法是：如果你不够严谨，.NET平台能让你轻松写出性能低下的代码。
2. GC随机发生，时间不定
   垃圾回收行为是确定的，通过对内存分配模式、对象作用域、垃圾回收配置参数的调控，你可以明确指定其运行时机。虽然控制的方式与本机代码不同，但控制能力依然存在。
3. 当问题发生时，怀疑是Framework的问题
   首先应当考虑的一定是程序本身，而不应该是Framework、操作系统或者硬件。
4. “过早的优化是万恶之源”，
   这是由Donald Knuth首先提出的。这句话仅适用于代码层面的微观优化。在设计阶段时，你需要理解整体架构和约束条件，不然你就会遗漏一些关键点，这将严重制约程序的运行。你必须在设计阶段就把性能目标预先考虑进去。

阿姆达尔定律:
S=1/(1-a+a/n)
系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强（加速）某部分功能处理的措施后可获得的性能改进或执行时间的加速比。简单来说是通过更快的处理器来获得加速是由慢的系统组件所限制。
阿姆达尔曾致力于并行处理系统的研究。对于固定负载情况下描述并行处理效果的加速比s，阿姆达尔经过深入研究给出了如下公式：
S=1/(1-a+a/n)
其中，a为并行计算部分所占比例，n为并行处理结点个数。这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式已被学术界所接受，并被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。

性能优化的四个优先级：
1. 算法
2. .net Framework
3. CLR
4. 汇编代码

在做性能优化计划或研究时，应该自上而下地进行。先确保程序结构和算法的合理性，再往下面几层推进。宏观的优化（macro-optimization）总是比微观优化（micro-optimization）更加有效。

确定评估内容（内存，CPU，尽可能详细明确），评估指标（量化目标值）

评估非常重要，没有评估就不会知道，性能问题出在哪里，性能的评估是一个持续性的过程，在使用开发工具、测试程序、监视工具时都应该穿插进行

![Fintech技术汇](https://img2020.cnblogs.com/blog/498574/202008/498574-20200801213206265-563825556.jpg)